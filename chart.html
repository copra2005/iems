<!DOCTYPE html>
<html>
<head>
  <script src="http://fb.me/react-0.13.0-rc1.js"></script>
  <script src="http://fb.me/react-with-addons-0.13.0-rc1.js"></script>
  <script src="http://fb.me/JSXTransformer-0.13.0-rc1.js"></script>
</head>
<body>
  <div id="example"></div>
  <style>
  body {
    font-family: Verdana;
    font-size: 12px;
  }
  .process rect {
    cursor: move;
    fill: #2ECC71;
    stroke: #000;
  }
  .process text {
    color: black;
  }
  .process .port-in circle {
    fill: #16A085;
    stroke: #000;
  }
  .process .port-out circle {
    fill: #E74C3C;
    stroke: #000;
  }
  .connector line, .port-line {
    stroke: #000;
    stroke-width: 1px;
  }
  .port-on {
    fill: yellow;
  }
  </style>
  <script type="text/jsx;harmony=true">
  var Draggable = React.createClass({
    getDefaultProps: function () {
      return { x: 0, y: 0 };
    },

    getInitialState: function () {
      return {
        pos: { x: this.props.x, y: this.props.y },
        dragging: false,
        rel: null // position relative to the cursor
      };
    },

    componentDidUpdate: function (props, state) {
      if (this.state.dragging && !state.dragging) {
        document.addEventListener('mousemove', this.onMouseMove);
        document.addEventListener('mouseup', this.onMouseUp);
      } else if (!this.state.dragging && state.dragging) {
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
      }
    },

    onMouseDown: function (e) {
      if (e.button !== 0) return; // only left mouse button
      this.setState({
        dragging: true,
        rel: {
          x: e.pageX - this.props.x,
          y: e.pageY - this.props.y
        }
      });
      e.stopPropagation();
      e.preventDefault();
    },

    onMouseUp: function (e) {
      this.setState({ dragging: false });
      e.stopPropagation();
      e.preventDefault();
    },

    onMouseMove: function (e) {
      if (!this.state.dragging) return;
      var pos = {
        x: e.pageX - this.state.rel.x,
        y: e.pageY - this.state.rel.y
      };
      this.setState({ pos: pos });
      if (this.props.onMove) {
        this.props.onMove(pos);
      }
      e.stopPropagation();
      e.preventDefault();
    },

    render: function () {
      return (
        <g {...this.props}
            transform={`translate(${this.state.pos.x},${this.state.pos.y})`}
            onMouseDown={this.onMouseDown} />
      );
    }
  });

  var Graph = React.createClass({
    render: function() {
      return <svg {...this.props}>{this.props.children}</svg>;
    }
  });

  var Connector = React.createClass({
    render: function() {
      return (
        <g className="connector">
          <line x1={this.props.source.x} y1={this.props.source.y}
                x2={this.props.target.x} y2={this.props.target.y} />
        </g>
      );
    }
  });

  var Port = React.createClass({
    getInitialState: function () {
      return {
        pos: { x: this.props.x, y: this.props.y },
        dragging: false,
        rel: null
      };
    },

    componentDidUpdate: function (props, state) {
      if (this.state.dragging && !state.dragging) {
        document.addEventListener('mousemove', this.onMouseMove);
        document.addEventListener('mouseup', this.onMouseUp);
      } else if (!this.state.dragging && state.dragging) {
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
      }
    },

    onMouseDown: function (e) {
      if (e.button !== 0) return; // only left mouse button
      this.setState({
        dragging: true,
        rel: {
          x: e.pageX - +this.props.x,
          y: e.pageY - +this.props.y
        }
      });
      e.stopPropagation();
      e.preventDefault();
    },

    onMouseUp: function (e) {
      this.setState({ dragging: false });
      e.stopPropagation();
      e.preventDefault();
    },

    onMouseMove: function (e) {
      if (!this.state.dragging) return;
      var pos = {
        x: e.pageX - this.state.rel.x,
        y: e.pageY - this.state.rel.y
      };
      this.setState({ pos: pos });
      e.stopPropagation();
      e.preventDefault();
    },

    onMouseOver: function(e) {
      this.setState({ on: true });
    },

    onMouseOut: function(e) {
      this.setState({ on: false });
    },

    render: function() {
      var line = null;
      if (this.state.dragging) {
        line = <line x1={this.props.x} y1={this.props.y}
                     x2={this.state.pos.x} y2={this.state.pos.y} className="port-line"/>;
      }

      var fill = this.state.on ? "yellow" : "red";

      return (
        <g className={`port port-${this.props.type}`}>
          <text x={+this.props.x-(this.props.label.length*2)} y={+this.props.y+(this.props.type == 'in' ? -20 : 30)}>{this.props.label}</text>
          <circle cx={this.props.x} cy={this.props.y} r="10" fill={fill}
                  onMouseDown={this.onMouseDown}
                  onMouseOver={this.onMouseOver}
                  onMouseOut={this.onMouseOut} />
          {line}
        </g>
      );
    }
  });

  var Group = React.createClass({
    render: function() {
      return (
        <Process name={this.props.name} ports={this.props.ports}>
          {this.props.children}
        </Process>
      );
    }
  });

  var Process = React.createClass({
    render: function() {
      var offset = {
        x: this.props.width / (this.props.ports.in.length+1),
        y: this.props.width / (this.props.ports.out.length+1)
      };
      return (
        <Draggable className="process" x={this.props.x} y={this.props.y} onMove={this.props.onMove}>
          <g>
            <rect x="0" y="0" width={this.props.width} height={this.props.height}/>
            <text x="10" y="30">{this.props.name}</text>
            <g>{this.props.ports.in.map((port, index) => <Port key={port} label={port} type="in" x={(index+1)*offset.x} y={0}/>)}</g>
            <g>{this.props.ports.out.map((port, index) => <Port key={port} label={port} type="out" x={(index+1)*offset.y} y={this.props.height}/>)}</g>
          </g>
          <g>
            {this.props.children}
          </g>
        </Draggable>
      );
    }
  });

  var App = React.createClass({
    getInitialState: function() {
      return {
        groups: [
          {
            x: 300, y: 50,
            ports: { in: ['src', 'trg'], out: ['alignments'] },
            processes: [
              { name: 'fastalign', x: 20, y: 50, ports: { in: ['src', 'trg'], out: ['out'] } },
              { name: 'fastalign rev', x: 200, y: 50, ports: { in: ['src', 'trg'], out: ['out'] } },
              { name: 'sym', x: 120, y: 200, ports: { in: ['src-trg', 'trg-src'], out: ['out'] } },
            ],
            links: [
              { from: { process: null, port: 0 }, to: { process: 0, port: 0 } },
              { from: { process: null, port: 1 }, to: { process: 0, port: 1 } },
              { from: { process: null, port: 0 }, to: { process: 1, port: 1 } },
              { from: { process: null, port: 1 }, to: { process: 1, port: 0 } },
              { from: { process: 0, port: 0 }, to: { process: 2, port: 0 } },
              { from: { process: 1, port: 0 }, to: { process: 2, port: 1 } },
              { from: { process: 2, port: 0 }, to: { process: null, port: 0 } },
            ]
          },
          { process: { name: 'wget', x: 20, y: 50, ports: { in: [], out: ['out'] } } },
          { process: { name: 'tokenizer', x: 20, y: 200, ports: { in: ['in'], out: ['out'] } } },
          { process: { name: 'kelnm', x: 20, y: 350, ports: { in: ['in'], out: ['out'] } } },
        ]
      }
    },

    render: function() {


      var groups = this.state.groups.map(group => {
        var pos = {x:group.x, y:group.y}

        var width = 150;
        var height = 50;

        var pwidth = 150;
        var pheight = 50;

        if (!group.processes) {
          group.blank = true;
          group.ports = { in: [], out: [] }
          group.processes = [group.process];
        }

        var processes = group.processes.map(p => {
          width = Math.max(width, p.x + pwidth);
          height = Math.max(height, p.y + pheight);

          var callback = pos => {
            p.x = pos.x;
            p.y = pos.y;
            this.setState({groups: this.state.groups})
          };

          return <Process width={pwidth} height={pheight} name={p.name} x={p.x} y={p.y} ports={p.ports} onMove={callback}/>;
        });

        if (processes.length) {
          width += 20;
          height += 50;
        }

        var links = group.links ? group.links.map(l => {
          var source = {}, target = {};
          if (l.from.process !== null) {
            var p = group.processes[l.from.process];
            source.x = p.x + (l.from.port+1)*(pwidth/(p.ports.out.length+1));
            source.y = p.y + pheight+10;
          } else {
            source.x = (l.from.port+1)*(width/(group.ports.in.length+1));
            source.y = 10;
          }
          if (l.to.process !== null) {
            var p = group.processes[l.to.process];
            target.x = p.x + (l.to.port+1)*(pwidth/(p.ports.in.length+1));
            target.y = p.y - 10;
          } else {
            target.x = (l.to.port+1)*(width/(group.ports.out.length+1));
            target.y = height-10;
          }

          return (
            <Connector source={source}
                       target={target}/>
          )
        }) : null;

        if (group.blank) {
          return processes[0];
        }

        return (
          <Process width={width} height={height} name={group.name} ports={group.ports} x={pos.x} y={pos.y}>
            {processes}
            {links}
          </Process>
        )
      });

      return (
        <Graph width="1000" height="1000">
          {groups}
        </Graph>
      );
    }
  });

  React.render(
    <App/>,
    document.getElementById('example')
  );
  </script>
</body>
</html>
